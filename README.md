# 🚀 동시성 제어 테스트 프로젝트 (Concurrency Control Test)

이 프로젝트는 **다중 스레드 환경에서 데이터 정합성을 유지하기 위한 다양한 동시성 제어 전략을 비교·분석**하기 위해 제작되었습니다.  
Java/Spring 환경에서 자주 사용되는 동시성 제어 방식들을 실제 코드와 테스트를 통해 검증합니다.

---

## 📌 1. Synchronized (Intrinsic Lock)

Java의 **고유 락(Intrinsic Lock)** 을 이용한 방식입니다.

### 🔧 구현 방법
- 메서드 시그니처 또는 코드 블록에 `synchronized` 키워드 적용

### ✨ 특징
- JVM 수준에서 **한 번에 하나의 스레드만 접근 허용**
- 구현이 가장 단순하고 직관적

### ⚠️ 한계
- **분산 환경(서버 2대 이상)에서는 동작하지 않음**
  - 각 서버 JVM 내부에서만 락이 유효
- 인스턴스 단위로 락이 걸리므로 **락 범위 설정에 주의 필요**

---

## 📌 2. Pessimistic Lock (비관적 락)

데이터 충돌이 발생할 것이라 가정하고, **DB 수준에서 물리적인 락을 선점**하는 방식입니다.

### 🔧 구현 방법
- JPA의 `@Lock(LockModeType.PESSIMISTIC_WRITE)`
- 내부적으로 `SELECT ... FOR UPDATE` 쿼리 실행

### ✨ 특징
- 트랜잭션 시작 시 락을 획득하여 **강력한 데이터 정합성 보장**
- 충돌이 빈번한 시스템에 적합  
  - 예: 수강신청, 선착순 이벤트, 재고 차감

### ⚠️ 단점
- 락 대기로 인한 **성능 저하 가능성**
- 잘못 설계 시 **데드락(Deadlock) 발생 위험**

---

## 📌 3. Optimistic Lock (낙관적 락)

충돌이 거의 없다고 가정하고, **버전 정보를 이용해 충돌을 감지**하는 방식입니다.

### 🔧 구현 방법
- 엔티티에 `@Version` 컬럼 추가
- UPDATE 시 버전 일치 여부 검증

### ✨ 특징
- DB의 물리적인 락을 사용하지 않아 **동시 처리 성능 우수**
- 분산 환경에서도 안전하게 사용 가능
- 충돌 발생 시 `OptimisticLockException` 발생

### ⚠️ 단점
- 충돌 발생 시 **직접 재시도(Retry) 로직 구현 필요**
- 충돌이 잦은 경우  
  → 반복적인 롤백 & 재시도로 인해 비관적 락보다 성능 저하 가능

---

## 📊 4. 핵심 비교 요약

| 비교 항목 | Synchronized | Pessimistic Lock | Optimistic Lock |
|---------|-------------|------------------|----------------|
| 제어 위치 | Application (JVM) | Database (Row-level) | Application + DB (Version) |
| 속도 | 빠름 (단일 서버) | 느림 (락 대기 발생) | 매우 빠름 (충돌 없을 시) |
| 확장성 | 낮음 (서버 1대 제한) | 높음 | 높음 |
| 충돌 대응 | 순차 처리 | 대기(Wait) | 예외 발생 및 재시도 |

---

## 🧪 5. 테스트 케이스 (Test Cases)

각 동시성 제어 전략의 유효성을 검증하기 위해 다음 시나리오를 수행합니다.

### ✅ 동시성 테스트
- `ExecutorService` + `CountDownLatch` 사용
- **100개의 스레드가 동시에 하나의 재고를 감소**

### ✅ 데이터 무결성 검증
- 100번의 요청 이후  
  → 남은 재고가 **초기값 - 100** 인지 검증

### ✅ 성능 측정
- 각 전략별로 **100회 요청 처리 시간 측정 및 비교**

---

## 🎯 목적

- 동시성 제어 방식별 **장단점과 적용 시나리오를 명확히 이해**
- 단순 구현을 넘어 **실무에서 발생 가능한 정합성 이슈를 코드로 검증**
- 트래픽 특성에 맞는 **합리적인 락 전략 선택 기준 수립**
